## すごいH本イントロダクション
### 命令型プログラミング言語
- 命令の並びをコンピュータに与えてそれを実行
- 実行中、状態の変更可
  - ex) 変数aの値変更
- 繰り返し実行のための構文あり
  - ex) for, while

### 純粋関数型言語
- Haskell(1987〜)
- 何をしろは伝えず、何であるよを伝える
  - 前者が命令型
  - ex) ある数の階乗とは1からその数までの積である
- 純粋ではない
  - Erlang

### Haskell
- 必要になるまで関数を実行しない
  - <b><span style="color: orange; ">遅延評価</b>
    - 参照透明だから許される
    - それがいつ計算されるのか気にする必要ない
    - 表示しないといけない時、必要最小限の計算
    - 見かけ上無限のデータを扱うことを可能
      -実際に画面に表示するデータのみが計算されるため
    - Swiftでいうlazy
- 高度な概念が用いられているのでコード量少ない
  - 少ない ＝ 保守しやすい, バグも少なくなる

### 特徴: 値は<b><span style="color: orange; ">変更不可</b>
- 再代入可能な変数使わない or 極力避ける
  - その方が動作理解しやすい
  - テストしやすい
  - バグの原因取り除ける
- 命令型: 状態をクラスにカプセル化
  - 状態の影響範囲を局所化
  - RxはObservableに包んでアプリ側のコードから再代入可能な変数を削除→状態が原因のバグを潰せる
- コードの中にletしか出てこない
  - イミュータブルなデータ

### 特徴: 参照透明で副作用のない関数
- <b><span style="color: orange; ">参照透明性</b>
  - 入力が同じなら出力も同じという特性
    - 入力値(引数)以外に変化するものが無い
- <b><span style="color: orange; ">副作用</b>
  - 戻り値以外に出力がない(外部に影響を及ぼさない)
  - ex) Rx 副作用発生する場合
    - ColdなObに包んでしまう
      - doでイベントシーケンスに影響を与えないように
- 計算して結果を返すだけ
  - 返ってくるものが決まってる
    - 関数の正しさを推測, 証明できる
  - 単純な関数を組み合わせ
  - 複雑な正しい関数を組み立てることができる
- RxでObに適用するオペレータが渡す処理
  - 関数(それがこれ)
  - Rxは読みにくい
    - パイプライン演算子が無い(Elm, Elixir)
      - Haskellにも無い
  - Swiftではメソッドとしてドット演算子で繋ぐ

### ex) 低遅延
- あるリストの数を倍の倍の倍にしたい
  - 命令型
```
let hoges = [1,2,3]
// hogesを関数に渡す → コピー作成 → 結果返す
```
  - 関数型(遅延評価)
```
doubleMe(doubleMe(doubleMe(xs)))
```
- 「結果表示して」命令ない限り何もしない
- 実行後
  - 1,2,3と順番にdoubleMe実行
  - 3重に呼び出してもリストは要求があった時にだけ一度だけ処理する